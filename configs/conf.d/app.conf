# demo server exposing multiple njs use-cases on one port
server {
  listen 8080;
  server_name _;

  # ---------- internal helpers ----------
  # feature flags "service v2" decision (returns 'on' or 'off')
  location = /_int/flags {
    internal;
    js_content edge.flags_logic;
  }

  # ---------- demo upstreams (no real proxy; simulated) ----------
  location = /v1/hello {
    default_type application/json;
    return 200 '{ "service":"v1", "hello":"world", "ts":"$msec" }\n';
  }
  location = /v2/hello {
    default_type application/json;
    return 200 '{ "service":"v2", "hello":"world", "ts":"$msec" }\n';
  }

  # ---------- use-case 1: HMAC signing header (no proxy) ----------
  # Attach HMAC signature for the request. In real reverse-proxy, you'd use proxy_set_header X-Sign $hmac;
  location = /sign {
    add_header X-Time $msec always;
    add_header X-Sign $hmac always;
    return 204;
  }

  # ---------- use-case 2 & 3: access-phase gate + canary/FF routing ----------
  # - js_access edge.gate performs:
  #    * require x-api-key (example)
  #    * subrequest to /_int/flags to choose v1/v2
  #    * internalRedirect to /v1/hello or /v2/hello
  # location = /api/hello {
  #   js_access edge.gate;
  #   # this response will be bypassed because gate() does internalRedirect()
  #   return 204;
  # }

  # ---------- use-case 4: response redaction via body filter ----------
  # raw report with sensitive data
  location = /report {
    default_type application/json;
    return 200 '{ "name":"alice", "phone":"+6281234567890", "cc":"4111111111111111" }\n';
  }

  # filtered view
  location = /report-filtered {
    proxy_pass http://127.0.0.1:8080/report;
    js_header_filter f.json_hdr;
    js_body_filter   f.redact_pii;
  }

  # root
  location = / {
    return 200 "ok\n";
  }
}
